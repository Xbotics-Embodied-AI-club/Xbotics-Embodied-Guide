#### 3、IsaacLab 任务基准
以下列表包含在 Isaac Lab 中可用的所有 RL 和 IL 任务实现。尽管我们尽量保持此列表最新，您仍可以通过运行以下命令获取最新的环境列表:

```shell
./isaaclab.sh -p scripts/environments/list_envs.py
```

##### 3.1 单一智能体

###### 经典

基于 IsaacGymEnvs 实现的 MuJoCo 风格环境的经典环境。
<img width="819" height="572" alt="image" src="https://github.com/user-attachments/assets/ceb5b2c9-edef-4a22-8e30-45b65840ca7b" />
<img width="819" height="524" alt="image" src="https://github.com/user-attachments/assets/bf50f301-0c46-4502-ab4d-f1f23754a3b1" />


###### 操作臂

基于固定机械臂操作任务的环境。

对于许多这些任务，我们包括具有不同手臂动作空间的配置。例如，对于 lift-cube 环境:

Isaac-Lift-Cube-Franka-v0: Franka机械臂关节位置控制

Isaac-Lift-Cube-Franka-IK-Abs-v0: Franka机械臂绝对IK控制

Isaac-Lift-Cube-Franka-IK-Rel-v0: Franka机械臂相对IK控制

<img width="785" height="703" alt="image" src="https://github.com/user-attachments/assets/96d2c64d-9192-40bb-bd51-33c433ef4ee9" />
<img width="792" height="478" alt="image" src="https://github.com/user-attachments/assets/5e8b1723-e46e-4c37-aef6-ad02ad686b53" />
<img width="875" height="542" alt="image" src="https://github.com/user-attachments/assets/0c2e2116-19e1-41b2-a9b4-eecd112c7c28" />
<img width="878" height="601" alt="image" src="https://github.com/user-attachments/assets/409fc01c-1490-4340-a370-0f11d8896ffd" />
<img width="872" height="767" alt="image" src="https://github.com/user-attachments/assets/304d50e4-7386-416c-8b85-fbcae4ad14b5" />
<img width="875" height="565" alt="image" src="https://github.com/user-attachments/assets/165a27f6-4e8e-4538-863a-0bd169d555f6" />
<img width="875" height="338" alt="image" src="https://github.com/user-attachments/assets/075e7193-3e1b-4642-a419-b9e9a4589702" />


###### 富接触操控

基于富接触操控的环境，例如销钉插入、齿轮啮合和螺母螺栓紧固。

这些任务共享相同的任务配置和控制选项。您可以通过指定任务名称在它们之间切换。例如:

Isaac-Factory-PegInsert-Direct-v0: 使用Franka机械臂进行销钉插入

Isaac-Factory-GearMesh-Direct-v0: 与Franka机械臂啮合的齿轮

Isaac-Factory-NutThread-Direct-v0: 用Franka机械臂进行螺母螺栓紧固

<img width="875" height="743" alt="image" src="https://github.com/user-attachments/assets/c294b29c-f5b7-4b6c-8b89-02edd1e880e9" />


###### 自动装配

基于100种不同装配任务的环境，每个任务都涉及将插头插入插座的操作。这些任务共享相同的配置框架，但通过零部件的几何形状和物理属性实现差异化。

可通过指定对应的资产ID切换不同任务，可用资产ID包括:

‘00004’, ‘00007’, ‘00014’, ‘00015’, ‘00016’, ‘00021’, ‘00028’, ‘00030’, ‘00032’, ‘00042’, ‘00062’, ‘00074’, ‘00077’, ‘00078’, ‘00081’, ‘00083’, ‘00103’, ‘00110’, ‘00117’, ‘00133’, ‘00138’, ‘00141’, ‘00143’, ‘00163’, ‘00175’, ‘00186’, ‘00187’, ‘00190’, ‘00192’, ‘00210’, ‘00211’, ‘00213’, ‘00255’, ‘00256’, ‘00271’, ‘00293’, ‘00296’, ‘00301’, ‘00308’, ‘00318’, ‘00319’, ‘00320’, ‘00329’, ‘00340’, ‘00345’, ‘00346’, ‘00360’, ‘00388’, ‘00410’, ‘00417’, ‘00422’, ‘00426’, ‘00437’, ‘00444’, ‘00446’, ‘00470’, ‘00471’, ‘00480’, ‘00486’, ‘00499’, ‘00506’, ‘00514’, ‘00537’, ‘00553’, ‘00559’, ‘00581’, ‘00597’, ‘00614’, ‘00615’, ‘00638’, ‘00648’, ‘00649’, ‘00652’, ‘00659’, ‘00681’, ‘00686’, ‘00700’, ‘00703’, ‘00726’, ‘00731’, ‘00741’, ‘00755’, ‘00768’, ‘00783’, ‘00831’, ‘00855’, ‘00860’, ‘00863’, ‘01026’, ‘01029’, ‘01036’, ‘01041’, ‘01053’, ‘01079’, ‘01092’, ‘01102’, ‘01125’, ‘01129’, ‘01132’, ‘01136’.

我们同时提供拆卸与装配两种任务环境。

###### 注意

建议使用 CUDA 与 570 驱动程序运行 AutoMate 环境。如果在架构为 x86_64 的 Linux 上使用 Nvidia 驱动程序 570 运行，我们按照以下步骤安装 CUDA 12.8。这允许在 AutoMate 环境中使用 CUDA 计算奖励。如果您有不同的操作系统或架构，请参阅 CUDA installation page 获取其他说明。

```shell
wget https://developer.download.nvidia.com/compute/cuda/12.8.0/local_installers/cuda_12.8.0_570.86.10_linux.run
sudo sh cuda_12.8.0_570.86.10_linux.run --toolkit
```
使用 conda 时，可以通过以下命令安装 CUDA 工具包:

```shell
conda install cudatoolkit
```
使用 580 驱动程序和 CUDA 13，我们目前无法启用 CUDA 来计算奖励。代码会自动回退到 CPU，导致性能略慢。


Isaac-AutoMate-Disassembly-Direct-v0: 初始状态下插头已插入插座，底层控制器会将插头拔出并移至随机位置。这个过程完全由脚本控制，不涉及任何学习策略，因此不需要进行策略训练或评估。这些结果轨迹可作为逆向学习（即装配学习）的示范数据。运行指定任务的拆卸模式: ```python source/isaaclab_tasks/isaaclab_tasks/direct/automate/run_disassembly_w_id.py --assembly_id=ASSEMBLY_ID --disassembly_dir=DISASSEMBLY_DIR```. 所有生成的轨迹存储在本地文件夹 DISASSEMBLY_DIR 中。

Isaac-AutoMate-Assembly-Direct-v0: 目标是将插头插入插座。你可以使用这个环境通过强化学习训练策略，或评估预训练模型。

要训练装配策略，我们运行命令 ```python source/isaaclab_tasks/isaaclab_tasks/direct/automate/run_w_id.py --assembly_id=ASSEMBLY_ID --train ```。我们可以通过可选参数自定义训练流程: 使用 --headless 以无界面模式运行（不打开GUI窗口）， --max_iterations=MAX_ITERATIONS 设置训练迭代次数， --num_envs=NUM_ENVS 设置训练时的并行环境数量， --seed=SEED 指定随机种子。训练过程中，策略检查点会自动保存在 logs/rl_games/Assembly/test 目录下。

要评估一个装配策略，我们运行命令 ```python source/isaaclab_tasks/isaaclab_tasks/direct/automate/run_w_id.py --assembly_id=ASSEMBLY_ID --checkpoint=CHECKPOINT --log_eval ```。评估结果存储在 evaluation_{ASSEMBLY_ID}.h5 。

<img width="872" height="500" alt="image" src="https://github.com/user-attachments/assets/556970ff-dba3-4da1-84b5-bfba6989851f" />

###### FORGE

FORGE 环境通过以下方式扩展了 Factory 环境:

力传感: 添加末端执行器所受力的观测值。

过度力惩罚: 添加一个选项来惩罚智能体超出接触力限制的行为。

动力学随机化: 随机化控制器增益、资产属性（摩擦、质量）和死区。

成功预测: 添加一个额外的动作来预测任务成功。

这些任务共享相同的任务配置和控制选项。您可以通过指定任务名称在它们之间切换。

Isaac-Forge-PegInsert-Direct-v0: 使用Franka机械臂进行销钉插入

Isaac-Forge-GearMesh-Direct-v0: 与Franka机械臂啮合的齿轮

Isaac-Forge-NutThread-Direct-v0: 用Franka机械臂进行螺母螺栓紧固

<img width="876" height="742" alt="image" src="https://github.com/user-attachments/assets/91ac4a06-863c-4756-b5f9-2cf45aa35fcc" />

###### 运动

基于四足运动任务的环境

<img width="875" height="608" alt="image" src="https://github.com/user-attachments/assets/e0e30d43-52f5-485a-a133-785b6501409c" />
<img width="877" height="561" alt="image" src="https://github.com/user-attachments/assets/8e994e60-c203-47bc-8351-7c6ef2ddbd50" />
<img width="874" height="559" alt="image" src="https://github.com/user-attachments/assets/ff5eb580-dbd5-4066-aa83-0f7439bb0c58" />
<img width="873" height="557" alt="image" src="https://github.com/user-attachments/assets/cc1b91d6-cbe1-4868-b2be-a784b90a28ee" />
<img width="870" height="559" alt="image" src="https://github.com/user-attachments/assets/11a3dc4b-fb75-4280-be68-4a042b8ef149" />
<img width="875" height="560" alt="image" src="https://github.com/user-attachments/assets/67396204-eeb1-44a7-893c-5dd5b6790036" />
<img width="879" height="376" alt="image" src="https://github.com/user-attachments/assets/eee9efc4-b6f4-484b-86a1-9960d167a29b" />

###### 导航

<img width="878" height="232" alt="image" src="https://github.com/user-attachments/assets/b19c2bd9-9f94-43aa-9900-83ecf88c670a" />


###### Others

备注：对抗运动先验 (AMP) 训练仅在 skrl 库中可用，因为它是当前集成的库中唯一一个开箱即用支持该功能的库（对于其他库，需要实现该算法和架构）。有关更多信息，请参见 skrl’s AMP Documentation 。可以通过向训练/播放脚本添加命令行输入 --algorithm AMP 来激活 AMP 算法。

为了评估，脚本的命令行输入 --real-time 允许环境和智能体之间的交互循环在可能的情况下实时运行。

<img width="877" height="439" alt="image" src="https://github.com/user-attachments/assets/e4fa59d3-93ab-466f-aa07-221331aba4f9" />


###### 空间展示

cartpole_showcase 文件夹包含示例任务（基于 Cartpole 和 Cartpole-Camera Direct 任务），用于定义/使用 Isaac Lab 支持的各种 Gymnasium 观测空间和动作空间。

备注：目前，仅 Isaac Lab 的 Direct 工作流支持定义除 Box 之外的观测空间和动作空间。请参阅 Direct 工作流的 observation_space / action_space 文档以获取更多详细信息。

下表总结了 Cartpole 和 Cartpole-Camera 任务中展示的不同观测空间与动作空间的组合。在训练和评估的任务名称中，用 <OBSERVATION> 和 <ACTION> 替换相应的观测空间和动作空间。

<img width="783" height="600" alt="image" src="https://github.com/user-attachments/assets/db025a0a-627a-4c5a-ab24-890a12259780" />

##### 3.2 多智能体

备注：真正的多智能体训练仅在 skrl 库中可用，更多信息请参见 多智能体文档 。它支持 IPPO 和 MAPPO 算法，可以通过在训练/回放脚本中添加命令行输入 --algorithm IPPO 或 --algorithm MAPPO 来激活。如果这些环境与其他库一起运行或没有 IPPO 或 MAPPO 标志，它们将在后台转换为单智能体环境。

###### 经典
<img width="874" height="232" alt="image" src="https://github.com/user-attachments/assets/b61a141e-2aa4-4c5d-bd75-547c23716ac0" />


###### 操作臂

基于固定机械臂操作任务的环境。

<img width="874" height="233" alt="image" src="https://github.com/user-attachments/assets/34f08534-6e5e-4070-8190-610f4f63fc01" />



###### 综合环境列表

对于在 推理任务名称 下列出不同任务名称的环境，请在运行 play.py 或任何推理工作流时使用提供的推理任务名称。这些任务提供了更适合推理的配置，包括从已训练好的检查点读取数据，并禁用训练时使用的运行时扰动。

<img width="877" height="729" alt="image" src="https://github.com/user-attachments/assets/08574079-d3da-4c6f-8cb7-60219aa02639" />
<img width="874" height="712" alt="image" src="https://github.com/user-attachments/assets/11f6182d-87ad-4d9d-9d2e-f4171082f232" />
<img width="872" height="764" alt="image" src="https://github.com/user-attachments/assets/83b91138-a7b5-4352-bd13-58fe94092b03" />
<img width="873" height="801" alt="image" src="https://github.com/user-attachments/assets/e3c81740-15cc-4775-b18c-6e1d247ae3f4" />
<img width="874" height="821" alt="image" src="https://github.com/user-attachments/assets/4ac1d9c2-7346-4979-bbdf-ab77b2560a16" />
<img width="871" height="728" alt="image" src="https://github.com/user-attachments/assets/e48d6ebf-b0f5-4b35-8a15-7a7b1f2df3e4" />
<img width="874" height="767" alt="image" src="https://github.com/user-attachments/assets/02ef9230-8afb-4ad6-a679-2f5b9d08b3ca" />
<img width="875" height="838" alt="image" src="https://github.com/user-attachments/assets/b1f30522-0267-46c4-95f1-91a13743aae8" />
<img width="875" height="792" alt="image" src="https://github.com/user-attachments/assets/544cff94-5f06-4d97-bb21-b9cf54f5c55e" />
<img width="873" height="768" alt="image" src="https://github.com/user-attachments/assets/53a84670-9af8-4d11-938d-7ccf2c516f0d" />
<img width="873" height="280" alt="image" src="https://github.com/user-attachments/assets/49a4c774-1f66-4e4b-9b14-f0cfacc811ab" />

#### 4、资产与场景：USD/URDF 导入、相机布局、光照与碰撞
##### 4.1 USD/URDF 导入
###### URDF文件数据集

转自：知乎huyoust

里面收集的资料也比较多，都分类整理了，有机械臂，双足，双臂，飞行器，执行器，仿人，四足，轮式等。实际上github上有很多awesome类型的项目，这些作者都有着极大的专注与热情，能省去自己找资料的麻烦，推荐感兴趣的去给他们点个免费的star。

<img width="1138" height="991" alt="image" src="https://github.com/user-attachments/assets/99ae23a8-af87-4a00-a3f0-cade61d33391" />
<img width="1260" height="1153" alt="image" src="https://github.com/user-attachments/assets/83ef113a-fc4e-42f9-b672-19e50b9e84d6" />
<img width="961" height="1065" alt="image" src="https://github.com/user-attachments/assets/c6c20490-e4ff-41a9-805d-a0411f0d9831" />
<img width="961" height="1065" alt="image" src="https://github.com/user-attachments/assets/1700a71c-f80d-41eb-84b6-ff88556a77df" />

最近在Github上找一个机械臂的URDF文件时，发现一个很好的仓库。这应该是目前整理的最好最全的关于工业机械臂的URDF文件的仓库了，地址如下：

[GitHub - Daniella1/urdf_files_dataset
github.com/Daniella1/urdf_files_dataset](https://github.com/Daniella1/urdf_files_dataset)
本来以为这也只是一个awesome xxx这样的资源收集型Git仓库，但是在README文件中看到，这个仓库还是一篇论文中的公开数据库：Understanding URDF: A Dataset and Analysis。点进去看一下全文，发现作者中居然有Peter Corke大佬，因此特意整理记录一下。

**（1）不同机器人仿真软件/工具**

机器人仿真软件/工具很多，通产每个仿真软件中的机器人模型都有自己原生的文件格式，下面表格所示为几种不同仿真软件原生模型的文件格式以及它们对URDF文件描述的机器人模型的支持性。可以看到，绝大部分的仿真软件都是支持导入URDF格式描述的机器人模型的。

<img width="775" height="459" alt="image" src="https://github.com/user-attachments/assets/def5a6a8-281a-49d1-a1a9-7097d1be6abf" />

不同机器人仿真工具对URDF文件的支持

**（2）为什么是URDF格式**

URDF，全称是Unified Robot Description Format，统一机器人描述格式。URDF文件格式用于描述机器人最早是由机器人操作系统（ROS）的开发人员在2009年引入，是一种描述机器人的运动学、动力学和几何形状的通用格式文件，独立于软件程序，方便不同的软件工具以及开发人员共享机器人数据模型。URDF文件重要的一点是其可读性，因为它是XML类型的文本文件。URDF文件中可以描述机器人的运动学结构、动力学参数、视觉外观（通过引用其它文件）和几何碰撞边界（通过引用其它文件）。

关于URDF的更对细节可以参考：

[urdf/XML - ROS Wiki](https://wiki.ros.org/urdf/XML)

[urdf/Tutorials - ROS Wiki](https://wiki.ros.org/urdf/Tutorials)

**（3）URDF文件解析**

**模型（model）**
创建一个URDF文件的最小要求是机器人的名称和一个连杆。如下所示的URDF文件示例，它表示了一个2自由度的平面连杆机构，外观使用简单的几何形状：方块和圆柱，这个示例文件中有3个连杆和2个关节：

<img width="1135" height="540" alt="image" src="https://github.com/user-attachments/assets/8c95c4c2-38c7-4264-8eb6-9e5d6baff963" />

简单的平面3连杆机构

可以看到URDF文件中有一些关键的元素：

**连杆（link）**

连杆是可以使用关节进行连接的刚体，连杆有惯量（inertial）、视觉（visual）和碰撞（collision）等属性。惯性特性描述了连杆的质量、质心位置以及惯性矩。可视化特性和碰撞特性稍后再说。URDF中连杆只能是刚体，而不能是可形变的物体（在这一定程度上限制了URDF的应用范围，像涉及柔性体的机器人就不能用URDF文件直接表示）。

<img width="1505" height="698" alt="image" src="https://github.com/user-attachments/assets/a2f666ad-4683-4e26-aee4-08e9c823baeb" />

更通用的连杆属性

前面的示例模型中，3个连杆的名称分别为“base link”、“link 1”和“link 2”。我们查看“基本链接”来说明如何指定链接，参见第3-10行的清单1。“base link”表示机器人的固定底座，其中它的视觉属性由一个原点和一个由一个方块组成的几何体来定义，方块的大小由其三个边的长度指定。一个连杆唯一的必需属性的是它的名称，在一个URDF文件中，连杆名称必须是唯一的，不同连杆的名称必须不同。

**关节（joint）**

关节用于连接两个连杆，一个父连杆和一个子连杆。父连杆是更靠近基座的连杆，子连杆是更靠近末端工具的连杆。关节的主要参数是关节类型（运动学）、动力学参数，以及活动范围。关节类型包括：

旋转关节（revolute）：特指关节运动范围有明确的上限和下限的转动关节。
连续关节（continuous）：关节运动范围无限的转动关节，即可以连续旋转的转动关节。
平移关节（prismatic）：沿轴滑动的滑动关节，运动范围有明确的上限和下限。
固定关节（fixed）：类似于焊接，不是真正的关节，因为它无法移动，所有自由度都被锁定。这种类型的关节不需要<Axis>，<calibration>，<dynamics>，<limits>或<seafe_controller>等参数。
浮动关节（floating）：允许所有6个自由度的运动。
平面关节（planar）：允许在垂直于轴的平面中运动。
关节也有很多可以编辑的属性：

<img width="887" height="798" alt="image" src="https://github.com/user-attachments/assets/4bdb9c40-4aac-452b-8b36-6e5dd57250c1" />

**关节属性**

前面的示例模型中，关节的名称是“joint 1”和“joint 2”。关节类型是连续关节，这意味着它们是没有运动限制的旋转关节。“axis”属性指定关节轴的方向，在本例中，关节轴沿着Y轴。关节的必需属性是它的父连杆和子连杆的名称、关节类型和关节名称。

可视化与碰撞几何形状（Visual and Collision Geometries）
几何对象用于表示机器人连杆的形状，用于可视化或碰撞的目的，统称为网格对象（mesh），它们由一组构成对象表面的三角面组成。网格中的多边形越多，形状的细节级别就越高，但会以牺牲渲染和计算时间为代价。

网格对象可以用不同的CAD文件类型，每种文件类型都有不同的内部格式，并有其自身的好处和限制，因此应该根据使用的应用程序进行选择。URDF中可视化和碰撞网格的一种常用格式是STL（文件扩展名为.stl），它只使用三角形而不使用颜色或纹理信息来表示三维表面几何图形。另一种通常用于可视化的文件格式为collada（文件扩展名为.dae），它同时支持颜色和纹理信息。OBJ格式（文件扩展名为.obj）支持颜色、纹理和自由形式的曲线，允许更高级的细节可视化，但是，颜色和纹理数据存储在一个单独的（.mtl）文件中。

在URDF的一些应用中，碰撞检测是必需的，而在其他应用中，URDF模型仅用于可视化目的。根据应用程序的不同，URDF Bundle中可以包含不同类型的网格对象。例如，通常同时使用STL和COLLADA网格，因为STL网格不包含颜色与纹理，可以减少计算和渲染时间，同时STL可以进行凸包运算简化形状，因此常用于表示连杆的碰撞几何形状（碰撞检测通常需要大量运算，但是不需要关注结构细节，例如螺丝、螺帽、细孔这些），而COLLADA网格由于可以设置颜色、纹理等属性，因此通常作为连杆的可视化对象，提供高质量的可视化效果。

**URDF文件包（URDF Bundle/package）**

一个URDF机器人模型通常包含描述机器人拓扑结构的URDF文件以及描述机器人物理外观网格文件组成。URDF文件本身（具有.urdf文件扩展名）和URDF文件中所引用的网格对象（作为link的属性）所组成的文件集，通常称为URDF包。如下所示的URDF文件包，包含了名为myrobot.urdf的URDF文件，以及mesh文件夹中网格对象。URDF文件是指使用相对路径生成的不同链接的几何网格文件。

<img width="753" height="249" alt="image" src="https://github.com/user-attachments/assets/123e8480-fed5-430c-bdc7-8be4b0d6f6e7" />

**Xacro文件**

从前面可以看到，URDF文件适合定义静态的、完整的机器人模型，但对于复杂的机器人，URDF 可能会显得冗长且难以维护。Xacro是一种基于 XML 的宏扩展语言，主要用于简化和生成 URDF。Xacro 允许使用宏（macros）、变量、数学运算和参数化的方式来定义机器人模型，以提高可重用性和可读性。例如：

减少重复代码：可以定义一个通用的部件并多次使用
参数化设计：允许调整不同参数来生成不同的 URDF 结构
数学计算：可在 XML 内部执行计算，避免手动计算坐标或尺寸
Xacro 文件最终会被解析成标准 URDF 文件，例如在ROS中可以使用如下命令将 Xacro 转换为 URDF：

rosrun xacro xacro my_robot.xacro > my_robot.urdf
关于Xacro的具体内容这里暂不展开，感兴趣的可以参考：

Using Xacro to Clean Up a URDF File

**（4）URDF数据库**

对于大多数工业机械臂，由于其结构参数与特征都是固定的，因此在使用不同的软件工具进行算法仿真的时候，除非是初期的学习，通常都没必要自己再手动建模一遍，都是找现成的URDF文件，因为绝大多数机器人仿真软件都支持URDF格式文件的导入。前面提到的Understanding URDF: A Dataset and Analysis这篇文章中，作者规范地整理了超过300个不同来源的公开的URDF模型。
<img width="781" height="263" alt="image" src="https://github.com/user-attachments/assets/e560d938-e36f-4922-9804-5f791ba1ca70" />
<img width="648" height="828" alt="image" src="https://github.com/user-attachments/assets/db6329a8-2554-4523-8274-a7205ad25914" />

补充数据库资源：
[https://github.com/robot-descriptions/awesome-robot-descriptions
github.com/robot-descriptions/awesome-robot-descriptions](https://github.com/robot-descriptions/awesome-robot-descriptions
github.com/robot-descriptions/awesome-robot-descriptions)

[GitHub - robot-descriptions/awesome-robot-descriptions: A curated list of awesome robot descriptions (URDF, MJCF)](https://github.com/robot-descriptions/awesome-robot-descriptions)

[https://github.com/robot-descriptions/awesome-robot-descriptions
github.com/robot-descriptions/awesome-robot-descriptions
](https://github.com/robot-descriptions/awesome-robot-descriptions
github.com/robot-descriptions/awesome-robot-descriptions
)

##### 4.2 相机布局

###### 配置仿真上下文

当从独立脚本启动仿真器时，用户可以完全控制播放、暂停和步进仿真器。所有这些操作都通过 仿真上下文 处理。它负责各种时间轴事件，并为仿真器配置 物理场景 。

在 Isaac Lab 中 , sim.SimulationContext 类继承了 Isaac Sim 的 isaacsim.core.api.simulation_context.SimulationContext ，以允许通过 Python 的 dataclass 对象配置仿真器，并处理仿真步进的某些复杂性。

对于本教程，我们将将物理和渲染时间步长设置为0.01秒。通过将这些数量传递给 sim.SimulationCfg ，然后用它创建仿真上下文的实例。
```python
    # Initialize the simulation context
    sim_cfg = SimulationCfg(dt=0.01)
    sim = SimulationContext(sim_cfg)
    # Set main camera
    sim.set_camera_view([2.5, 2.5, 2.5], [0.0, 0.0, 0.0])
```
创建仿真上下文后，我们只配置了作用于仿真场景的物理。这包括用于仿真的设备、重力矢量和其他高级求解器参数。现在还有两个主要步骤剩下来运行仿真:

设计仿真场景: 添加传感器、机器人和其他仿真对象

运行仿真循环: 使仿真器进行步进，并从仿真器中设置和获取数据

##### 4.3 光照与碰撞

###### 生成地面平面

GroundPlaneCfg 配置了一个类似网格的地面平面，其外观和大小等属性可修改。
```python
    # Ground-plane
    cfg_ground = sim_utils.GroundPlaneCfg()
    cfg_ground.func("/World/defaultGroundPlane", cfg_ground)
```

###### 生成灯光

可以将 不同类型的灯光基本体 生成到场景中。这些包括远光灯、球形灯、圆盘灯和圆柱灯。在本教程中，我们生成一个远光灯，这是一种远离场景无限远的灯，只朝一个方向发光。
```python
    # spawn distant light
    cfg_light_distant = sim_utils.DistantLightCfg(
        intensity=3000.0,
        color=(0.75, 0.75, 0.75),
    )
    cfg_light_distant.func("/World/lightDistant", cfg_light_distant, translation=(1, 0, 10))
```
###### 生成基本形状

在生成基本形状之前，我们介绍了一个变换基本体或Xform的概念。变换基本体是一个仅包含变换属性的基本体。它用于将其他基本体分组，并作为一个组对其进行变换。在这里，我们创建一个Xform基本体，将所有的基本形状分组在其中。
```python
    # create a new xform prim for all objects to be spawned under
    prim_utils.create_prim("/World/Objects", "Xform")
```
###### 实例
接下来，我们使用 ConeCfg 类生成一个圆锥体。可以指定圆锥体的半径、高度、物理属性和材质属性。默认情况下，物理和材质属性是禁用的。

我们生成的前两个圆锥 Cone1 和 Cone2 是视觉元素，不启用物理属性。
```python
    # spawn a red cone
    cfg_cone = sim_utils.ConeCfg(
        radius=0.15,
        height=0.5,
        visual_material=sim_utils.PreviewSurfaceCfg(diffuse_color=(1.0, 0.0, 0.0)),
    )
    cfg_cone.func("/World/Objects/Cone1", cfg_cone, translation=(-1.0, 1.0, 1.0))
    cfg_cone.func("/World/Objects/Cone2", cfg_cone, translation=(-1.0, -1.0, 1.0))
```
对于第三个圆锥 ConeRigid ，我们在配置类中设置刚体物理属性。通过这些属性，我们可以指定圆锥体的质量、摩擦力和弹性。如果未指定，它们将默认为USD Physics设置的默认值。
```python
    # spawn a green cone with colliders and rigid body
    cfg_cone_rigid = sim_utils.ConeCfg(
        radius=0.15,
        height=0.5,
        rigid_props=sim_utils.RigidBodyPropertiesCfg(),
        mass_props=sim_utils.MassPropertiesCfg(mass=1.0),
        collision_props=sim_utils.CollisionPropertiesCfg(),
        visual_material=sim_utils.PreviewSurfaceCfg(diffuse_color=(0.0, 1.0, 0.0)),
    )
    cfg_cone_rigid.func(
        "/World/Objects/ConeRigid", cfg_cone_rigid, translation=(-0.2, 0.0, 2.0), orientation=(0.5, 0.0, 0.5, 0.0)
    )
```
最后，我们生成一个长方体 CuboidDeformable ，其中包含可变形体物理属性。与刚体仿真不同，可变形体可以在其顶点之间具有相对运动。这对于仿真软体如布料、橡胶或果冻非常有用。需要注意的是，可变形体仅在GPU仿真中受支持，并且需要生成一个带有可变形体物理属性的网格对象。
```python
    # spawn a blue cuboid with deformable body
    cfg_cuboid_deformable = sim_utils.MeshCuboidCfg(
        size=(0.2, 0.5, 0.2),
        deformable_props=sim_utils.DeformableBodyPropertiesCfg(),
        visual_material=sim_utils.PreviewSurfaceCfg(diffuse_color=(0.0, 0.0, 1.0)),
        physics_material=sim_utils.DeformableBodyMaterialCfg(),
    )
    cfg_cuboid_deformable.func("/World/Objects/CuboidDeformable", cfg_cuboid_deformable, translation=(0.15, 0.0, 2.0))
```
从另一个文件生成
最后，可以从其他文件格式生成基本体，例如其他USD、URDF或OBJ文件。在本教程中，我们将一个表的USD文件生成到场景中。这个表是一个网格基本体，并且有一个与之关联的材质基本体。所有这些信息都存储在其USD文件中。
```python
    # spawn a usd file of a table into the scene
    cfg = sim_utils.UsdFileCfg(usd_path=f"{ISAAC_NUCLEUS_DIR}/Props/Mounts/SeattleLabTable/table_instanceable.usd")
    cfg.func("/World/Objects/Table", cfg, translation=(0.0, 0.0, 1.05))
```
上面的表被添加为场景的一个引用。简单来说，这意味着表实际上并没有添加到场景中，而是添加了一个指向表资产的 指针 。这允许我们修改表资产，并使更改以非破坏性的方式反映在场景中。例如，我们可以更改表的材质，而不实际修改表资产的底层文件。只有更改存储在USD场景中。

### 5、日志与回放：录制、重放、评测
#### 5.1 查看日志

在单独的终端中，您可以通过执行以下命令监视训练进度:
```python
# execute from the root directory of the repository
./isaaclab.sh -p -m tensorboard.main --logdir logs/sb3/Isaac-Cartpole-v0
```
播放经过训练的 agent
一旦训练完成，您可以通过执行以下命令来可视化经过训练的 agent:
```python
# execute from the root directory of the repository
./isaaclab.sh -p scripts/reinforcement_learning/sb3/play.py --task Isaac-Cartpole-v0 --num_envs 32 --use_last_checkpoint
```
上述命令将从 logs/sb3/Isaac-Cartpole-v0 目录加载最新的检查点。您也可以通过传递 --checkpoint 标志指定特定的检查点。


#### 6、**样板：Isaac Lab 最小上手（可复制运行）**

见【代码6-1，6-2，6-3】(详见 files/formulas/第六节.md) 分别为train.py, play.py 及 isaaclab.sh。

  ```bash
  # 环境（示例）
  conda create -n isaaclab python=3.10 -y
  conda activate isaaclab
  # 安装依赖（按官方指引）
  # ...
  # 运行最小任务（如 Isaac-Ant-v0）
  ./isaaclab.sh -p scripts/reinforcement_learning/rsl_rl/train.py --task=Isaac-Ant-v0 --headless
  ./isaaclab.sh -p scripts/reinforcement_learning/rsl_rl/play.py --task Isaac-Isaac-Ant-v0 --checkpoint model_999.pt
  ```

#### 7、IsaacLab资料汇总

##### 7.1 文档

[https://docs.omniverse.nvidia.com/](https://docs.omniverse.nvidia.com/)
[https://developer.nvidia.com/isaac/sim ](https://developer.nvidia.com/isaac/sim )

omniverse 开发者文档 [https://docs.omniverse.nvidia.com/dev-guide/latest/index.html](https://docs.omniverse.nvidia.com/dev-guide/latest/index.html)

isaac sim 开发者文档 [https://docs.omniverse.nvidia.com/isaacsim/latest/index.html](https://docs.omniverse.nvidia.com/isaacsim/latest/index.html)

isaac lab 开发者文档 [https://isaac-sim.github.io/IsaacLab/](https://isaac-sim.github.io/IsaacLab/)

isaac sim 写代码 API 参考文档 [https://docs.omniverse.nvidia.com/py/isaacsim/index.html](https://docs.omniverse.nvidia.com/py/isaacsim/index.html)

isaac extension 文档 [https://docs.omniverse.nvidia.com/py/isaacsim/index.html](https://docs.omniverse.nvidia.com/py/isaacsim/index.html)

ros ros2 文档 [https://docs.omniverse.nvidia.com/isaacsim/latest/ros_ros2_tutorials.html](https://docs.omniverse.nvidia.com/isaacsim/latest/ros_ros2_tutorials.html)

isaac lab 官方文档 [https://docs.robotsfan.com/isaaclab/source/setup/quickstart.html
](https://docs.robotsfan.com/isaaclab/source/setup/quickstart.html
)

##### 7.2 视频教程

[https://player.bilibili.com/player.html?bvid=BV1B24y1s7Hc&autoplay=0](https://player.bilibili.com/player.html?bvid=BV1B24y1s7Hc&autoplay=0)
讲义在百度网盘
资料链接： [https://pan.baidu.com/s/1RGOQ4UOwcEGEhWMZRyfDXA?pwd=kvq7](https://pan.baidu.com/s/1RGOQ4UOwcEGEhWMZRyfDXA?pwd=kvq7) 提取码: kvq7

[https://player.bilibili.com/player.html?bvid=BV1a44y1N79U&autoplay=0](https://player.bilibili.com/player.html?bvid=BV1a44y1N79U&autoplay=0)
AI 仓库：使用 Isaac Sim 和 Isaac ROS 实现视觉导航

##### 7.3 github 教程

[https://github.com/isaac-sim/IsaacSim-ros_workspaces](https://github.com/isaac-sim/IsaacSim-ros_workspaces)

[https://github.com/NVIDIA-AI-IOT/Nav2-with-Isaac-ROS-GEMs
](https://github.com/NVIDIA-AI-IOT/Nav2-with-Isaac-ROS-GEMs
)

[https://developer.nvidia.com/blog/accelerate-ai-enabled-robotics-with-advanced-simulation-and-perception-tools-in-nvidia-isaac-platform/
](https://developer.nvidia.com/blog/accelerate-ai-enabled-robotics-with-advanced-simulation-and-perception-tools-in-nvidia-isaac-platform/
)
